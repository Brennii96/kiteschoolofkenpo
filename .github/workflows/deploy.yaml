name: Test and Deploy Staging/Production

# Trigger only on tags matching staging-* or v* (assuming v* is for production)
on:
  push:
    tags:
      - 'staging-*'
      - 'v*' # Example: v1.0.0, v1.2.3 etc.

jobs:
  # ===================
  #      TEST JOB
  # ===================
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.4'
          extensions: gd, bcmath, redis, intl, pdo, pdo_mysql, imagick, sqlite, pdo_sqlite
          tools: composer:v2
          cache: 'composer'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      # --- Setup Test Environment BEFORE Composer Install ---
      - name: Create SQLite Database File
        run: |
          echo "Creating database directory and file..."
          mkdir -p database
          touch database/database.sqlite
          ls -la database/ # Add output to confirm file creation

      - name: Create .env for Testing
        run: |
          echo "Creating .env file for testing..."
          # Copy from .env.example if it exists, otherwise create a blank one
          php -r "file_exists('.env.example') && copy('.env.example', '.env');"
          # Append/overwrite necessary testing variables
          echo "APP_ENV=testing" >> .env
          echo "DB_CONNECTION=sqlite" >> .env
          # Ensure the path is absolute for the runner environment
          echo "DB_DATABASE=${{ github.workspace }}/database/database.sqlite" >> .env
          # Generate a temporary key needed for bootstrapping potentially
          echo "APP_KEY=base64:$(php -r 'echo base64_encode(random_bytes(32));')" >> .env
          echo "Required .env variables set for testing."
          # Optionally print the created .env for debugging (remove in production)
          # cat .env

      # --- Install Dependencies ---
      - name: Install Composer Dependencies (including dev)
        # Now composer install runs AFTER .env and DB file exist
        run: composer install --no-interaction --prefer-dist --optimize-autoloader
        # Note: Removed --no-dev as tests usually need dev dependencies like PHPUnit

      - name: Install NPM Dependencies
        run: npm ci

      # --- Run Tests ---
      # Generate a fresh key if tests specifically rely on it AFTER discovery/install
      # - name: Generate App Key (if needed post-install)
      #  run: php artisan key:generate

      - name: Run Migrations (on test DB)
        run: php artisan migrate --force

      - name: Run PHPUnit Tests
        run: php artisan test

      # Optional linters etc.
      # - name: Run Linter (e.g., Pint)
      #   run: ./vendor/bin/pint --test



  # =====================
  #      DEPLOY JOB
  # =====================
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    # This job depends on the 'test' job succeeding
    needs: test

    # Set environment variables based on the tag pushed
    env:
      # Default to production, override below if staging tag
      DEPLOY_HOST: ${{ secrets.HETZNER_HOST }}
      DEPLOY_USER: ${{ secrets.HETZNER_SSH_USER }}
      DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }} # e.g., /home/deployer/sites/www.domain
      ENVIRONMENT: production
      # Use the specific SSH key secret name you created
      SSH_KEY_SECRET: ${{ secrets.HETZNER_SSH_PRIVATE_KEY }}

    steps:
      - name: Determine Environment from Tag
        # Override env vars if it's a staging tag
        if: contains(github.ref_name, 'staging')
        run: |
          echo "DEPLOY_HOST=${{ secrets.HETZNER_HOST }}" >> $GITHUB_ENV
          echo "DEPLOY_USER=${{ secrets.HETZNER_SSH_USER }}" >> $GITHUB_ENV
          echo "DEPLOY_PATH=${{ secrets.STAGING_DEPLOY_PATH }}" >> $GITHUB_ENV # e.g., /home/deployer/sites/staging.domain
          echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          echo "Deploying to Staging environment..."
      - name: Announce Production Deployment
        # Use 'startsWith' for 'v*' tags to avoid matching staging tags like 'v1-staging' if format changes
        if: startsWith(github.ref_name, 'v') && !contains(github.ref_name, 'staging')
        run: echo "Deploying to Production environment..."

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Needed if your build process needs Git history

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.4'
          extensions: gd, bcmath, redis, intl, pdo, pdo_mysql, imagick
          tools: composer:v2
          # Cache composer dependencies
          cache: 'composer'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          # Cache npm dependencies
          cache: 'npm'

      - name: Install Composer Dependencies (Production Only)
        # IMPORTANT: No dev dependencies for the final build artifact
        run: composer install --no-interaction --prefer-dist --optimize-autoloader --no-dev

      - name: Install NPM Dependencies
        # Still need npm ci to get vite/etc. for the build step itself
        run: npm ci

      - name: Build Frontend Assets (Vite)
        run: npm run build

      - name: Prepare Clean Build Directory
        # Use rsync to copy only necessary files for deployment
        run: |
          rm -rf deploy_artifact
          mkdir deploy_artifact
          rsync -a --checksum ./ ./deploy_artifact \
            --exclude="/deploy_artifact" \
            --exclude="/.git" \
            --exclude="/.github" \
            --exclude="/node_modules" \
            --exclude="/storage" \
            --exclude="/public/storage" \
            --exclude=".env" \
            --exclude=".env.*" \
            --exclude="/tests" \
            --exclude="*.md" \
            --exclude="*.yml" \
            --exclude="*.yaml" \
            --exclude="*.lock" \
            --exclude="/database/database.sqlite" \
            --exclude="*.pem" \
            --exclude=".editorconfig" \
            --exclude=".styleci.yml" \
            --exclude="phpunit.xml" \
            # Add any other files/folders to exclude

      - name: Create Release Artifact from Clean Directory
        # Create the archive from within the clean directory for cleaner paths inside
        run: |
          tar -czf release.tar.gz -C deploy_artifact .

      # --- Deployment Steps ---
      - name: Upload Artifact via SCP
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          # Use the specific SSH key secret name passed via env var
          key: ${{ env.SSH_KEY_SECRET }}
          source: "release.tar.gz"
          target: "${{ env.DEPLOY_PATH }}" # Upload to the determined base deploy path

      - name: Deploy Release via SSH
        uses: appleboy/ssh-action@v1.0.3 # Check for latest version of ssh-action
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          # Use the specific SSH key secret name passed via env var
          key: ${{ env.SSH_KEY_SECRET }}
          script: |
            set -e # Exit immediately if a command exits with a non-zero status.

            # Use environment variables set earlier
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            RELEASES_DIR="$DEPLOY_PATH/releases"
            SHARED_DIR="$DEPLOY_PATH/shared"
            CURRENT_SYMLINK="$DEPLOY_PATH/current"
            RELEASE_ID=$(date +%Y%m%d%H%M%S)
            NEW_RELEASE_DIR="$RELEASES_DIR/$RELEASE_ID"

            echo "Starting deployment to ${{ env.ENVIRONMENT }}..."
            echo " Deploy Path: $DEPLOY_PATH"
            echo " Release ID: $RELEASE_ID"
            echo " New Release Dir: $NEW_RELEASE_DIR"

            # Create the new release directory
            echo " Creating new release directory..."
            mkdir -p $NEW_RELEASE_DIR

            echo " Extracting artifact..."
            # Artifact was uploaded to DEPLOY_PATH by scp-action
            tar xzf $DEPLOY_PATH/release.tar.gz -C $NEW_RELEASE_DIR
            rm $DEPLOY_PATH/release.tar.gz # Clean up uploaded archive

            echo " Linking shared files/directories..."
            ln -nfs $SHARED_DIR/.env $NEW_RELEASE_DIR/.env
            # Remove potential placeholders before linking
            rm -rf $NEW_RELEASE_DIR/storage
            ln -nfs $SHARED_DIR/storage $NEW_RELEASE_DIR/storage
            rm -rf $NEW_RELEASE_DIR/content
            ln -nfs $SHARED_DIR/content $NEW_RELEASE_DIR/content
            rm -rf $NEW_RELEASE_DIR/public/assets
            ln -nfs $SHARED_DIR/assets $NEW_RELEASE_DIR/public/assets

            echo " Running post-deploy commands in $NEW_RELEASE_DIR..."
            cd $NEW_RELEASE_DIR

            # Link storage (after linking shared storage)
            php artisan storage:link

            # Run Laravel / Statamic commands
            php artisan migrate --force
            php artisan optimize:clear
            php artisan config:cache
            php artisan route:cache
            php artisan view:cache
            php please stache:warm
            # Conditionally run commands if needed
            # if [ "${{ env.ENVIRONMENT }}" = "production" ]; then
            #   echo "Running production only commands..."
            #   # e.g., php please static:warmup
            # fi
            # Other commands:
            # php please static:clear
            # php please search:update --all

            echo " Setting permissions (adjust user/group and consider sudo)..."
            # Ensure DEPLOY_USER can run these or has passwordless sudo configured
            # Using DEPLOY_USER as owner, www-data as group (common setup)
            sudo chown -R ${{ env.DEPLOY_USER }}:www-data .
            # Set standard Laravel/Statamic permissions
            sudo find . -type f -exec chmod 664 {} \;
            sudo find . -type d -exec chmod 775 {} \;
            # Make specific directories writable by the group (web server)
            sudo chmod -R ug+rwx storage bootstrap/cache content public/assets public/build

            echo " Switching current symlink..."
            ln -nfs $NEW_RELEASE_DIR $CURRENT_SYMLINK

            echo " Reloading PHP-FPM (requires sudo)..."
            sudo systemctl reload php8.4-fpm

            echo " Cleaning up old releases (keeping last 3)..."
            # Use find for safer deletion, especially if release names could contain spaces/special chars
            cd $RELEASES_DIR
            find . -maxdepth 1 -type d -name "20*" | sort -r | tail -n +4 | xargs -r rm -rf

            echo " Deployment to ${{ env.ENVIRONMENT }} finished successfully!"
